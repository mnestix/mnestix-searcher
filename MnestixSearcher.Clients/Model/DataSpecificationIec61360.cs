// <auto-generated>
/*
 * BaSyx AAS Environment Component
 *
 * AAS Environment API
 *
 * The version of the OpenAPI document: 2.0
 * Contact: basyx-dev@eclipse.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using MnestixSearcher.Clients.Client;

namespace MnestixSearcher.Clients.Model
{
    /// <summary>
    /// DataSpecificationIec61360
    /// </summary>
    public partial class DataSpecificationIec61360 : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DataSpecificationIec61360" /> class.
        /// </summary>
        /// <param name="preferredName">preferredName</param>
        /// <param name="value">value</param>
        /// <param name="definition">definition</param>
        /// <param name="symbol">symbol</param>
        /// <param name="shortName">shortName</param>
        /// <param name="unit">unit</param>
        /// <param name="unitId">unitId</param>
        /// <param name="sourceOfDefinition">sourceOfDefinition</param>
        /// <param name="dataType">dataType</param>
        /// <param name="valueFormat">valueFormat</param>
        /// <param name="valueList">valueList</param>
        /// <param name="levelType">levelType</param>
        [JsonConstructor]
        public DataSpecificationIec61360(Option<List<LangStringPreferredNameTypeIec61360>?> preferredName = default, Option<string?> value = default, Option<List<LangStringDefinitionTypeIec61360>?> definition = default, Option<string?> symbol = default, Option<List<LangStringShortNameTypeIec61360>?> shortName = default, Option<string?> unit = default, Option<Reference?> unitId = default, Option<string?> sourceOfDefinition = default, Option<DataTypeEnum?> dataType = default, Option<string?> valueFormat = default, Option<ValueList?> valueList = default, Option<LevelType?> levelType = default)
        {
            PreferredNameOption = preferredName;
            ValueOption = value;
            DefinitionOption = definition;
            SymbolOption = symbol;
            ShortNameOption = shortName;
            UnitOption = unit;
            UnitIdOption = unitId;
            SourceOfDefinitionOption = sourceOfDefinition;
            DataTypeOption = dataType;
            ValueFormatOption = valueFormat;
            ValueListOption = valueList;
            LevelTypeOption = levelType;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Defines DataType
        /// </summary>
        public enum DataTypeEnum
        {
            /// <summary>
            /// Enum BLOB for value: BLOB
            /// </summary>
            BLOB = 1,

            /// <summary>
            /// Enum BOOLEAN for value: BOOLEAN
            /// </summary>
            BOOLEAN = 2,

            /// <summary>
            /// Enum DATE for value: DATE
            /// </summary>
            DATE = 3,

            /// <summary>
            /// Enum FILE for value: FILE
            /// </summary>
            FILE = 4,

            /// <summary>
            /// Enum HTML for value: HTML
            /// </summary>
            HTML = 5,

            /// <summary>
            /// Enum INTEGERCOUNT for value: INTEGER_COUNT
            /// </summary>
            INTEGERCOUNT = 6,

            /// <summary>
            /// Enum INTEGERCURRENCY for value: INTEGER_CURRENCY
            /// </summary>
            INTEGERCURRENCY = 7,

            /// <summary>
            /// Enum INTEGERMEASURE for value: INTEGER_MEASURE
            /// </summary>
            INTEGERMEASURE = 8,

            /// <summary>
            /// Enum IRDI for value: IRDI
            /// </summary>
            IRDI = 9,

            /// <summary>
            /// Enum IRI for value: IRI
            /// </summary>
            IRI = 10,

            /// <summary>
            /// Enum RATIONAL for value: RATIONAL
            /// </summary>
            RATIONAL = 11,

            /// <summary>
            /// Enum RATIONALMEASURE for value: RATIONAL_MEASURE
            /// </summary>
            RATIONALMEASURE = 12,

            /// <summary>
            /// Enum REALCOUNT for value: REAL_COUNT
            /// </summary>
            REALCOUNT = 13,

            /// <summary>
            /// Enum REALCURRENCY for value: REAL_CURRENCY
            /// </summary>
            REALCURRENCY = 14,

            /// <summary>
            /// Enum REALMEASURE for value: REAL_MEASURE
            /// </summary>
            REALMEASURE = 15,

            /// <summary>
            /// Enum STRING for value: STRING
            /// </summary>
            STRING = 16,

            /// <summary>
            /// Enum STRINGTRANSLATABLE for value: STRING_TRANSLATABLE
            /// </summary>
            STRINGTRANSLATABLE = 17,

            /// <summary>
            /// Enum TIME for value: TIME
            /// </summary>
            TIME = 18,

            /// <summary>
            /// Enum TIMESTAMP for value: TIMESTAMP
            /// </summary>
            TIMESTAMP = 19
        }

        /// <summary>
        /// Returns a <see cref="DataTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static DataTypeEnum DataTypeEnumFromString(string value)
        {
            if (value.Equals("BLOB"))
                return DataTypeEnum.BLOB;

            if (value.Equals("BOOLEAN"))
                return DataTypeEnum.BOOLEAN;

            if (value.Equals("DATE"))
                return DataTypeEnum.DATE;

            if (value.Equals("FILE"))
                return DataTypeEnum.FILE;

            if (value.Equals("HTML"))
                return DataTypeEnum.HTML;

            if (value.Equals("INTEGER_COUNT"))
                return DataTypeEnum.INTEGERCOUNT;

            if (value.Equals("INTEGER_CURRENCY"))
                return DataTypeEnum.INTEGERCURRENCY;

            if (value.Equals("INTEGER_MEASURE"))
                return DataTypeEnum.INTEGERMEASURE;

            if (value.Equals("IRDI"))
                return DataTypeEnum.IRDI;

            if (value.Equals("IRI"))
                return DataTypeEnum.IRI;

            if (value.Equals("RATIONAL"))
                return DataTypeEnum.RATIONAL;

            if (value.Equals("RATIONAL_MEASURE"))
                return DataTypeEnum.RATIONALMEASURE;

            if (value.Equals("REAL_COUNT"))
                return DataTypeEnum.REALCOUNT;

            if (value.Equals("REAL_CURRENCY"))
                return DataTypeEnum.REALCURRENCY;

            if (value.Equals("REAL_MEASURE"))
                return DataTypeEnum.REALMEASURE;

            if (value.Equals("STRING"))
                return DataTypeEnum.STRING;

            if (value.Equals("STRING_TRANSLATABLE"))
                return DataTypeEnum.STRINGTRANSLATABLE;

            if (value.Equals("TIME"))
                return DataTypeEnum.TIME;

            if (value.Equals("TIMESTAMP"))
                return DataTypeEnum.TIMESTAMP;

            throw new NotImplementedException($"Could not convert value to type DataTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="DataTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static DataTypeEnum? DataTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("BLOB"))
                return DataTypeEnum.BLOB;

            if (value.Equals("BOOLEAN"))
                return DataTypeEnum.BOOLEAN;

            if (value.Equals("DATE"))
                return DataTypeEnum.DATE;

            if (value.Equals("FILE"))
                return DataTypeEnum.FILE;

            if (value.Equals("HTML"))
                return DataTypeEnum.HTML;

            if (value.Equals("INTEGER_COUNT"))
                return DataTypeEnum.INTEGERCOUNT;

            if (value.Equals("INTEGER_CURRENCY"))
                return DataTypeEnum.INTEGERCURRENCY;

            if (value.Equals("INTEGER_MEASURE"))
                return DataTypeEnum.INTEGERMEASURE;

            if (value.Equals("IRDI"))
                return DataTypeEnum.IRDI;

            if (value.Equals("IRI"))
                return DataTypeEnum.IRI;

            if (value.Equals("RATIONAL"))
                return DataTypeEnum.RATIONAL;

            if (value.Equals("RATIONAL_MEASURE"))
                return DataTypeEnum.RATIONALMEASURE;

            if (value.Equals("REAL_COUNT"))
                return DataTypeEnum.REALCOUNT;

            if (value.Equals("REAL_CURRENCY"))
                return DataTypeEnum.REALCURRENCY;

            if (value.Equals("REAL_MEASURE"))
                return DataTypeEnum.REALMEASURE;

            if (value.Equals("STRING"))
                return DataTypeEnum.STRING;

            if (value.Equals("STRING_TRANSLATABLE"))
                return DataTypeEnum.STRINGTRANSLATABLE;

            if (value.Equals("TIME"))
                return DataTypeEnum.TIME;

            if (value.Equals("TIMESTAMP"))
                return DataTypeEnum.TIMESTAMP;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="DataTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string DataTypeEnumToJsonValue(DataTypeEnum? value)
        {
            if (value == DataTypeEnum.BLOB)
                return "BLOB";

            if (value == DataTypeEnum.BOOLEAN)
                return "BOOLEAN";

            if (value == DataTypeEnum.DATE)
                return "DATE";

            if (value == DataTypeEnum.FILE)
                return "FILE";

            if (value == DataTypeEnum.HTML)
                return "HTML";

            if (value == DataTypeEnum.INTEGERCOUNT)
                return "INTEGER_COUNT";

            if (value == DataTypeEnum.INTEGERCURRENCY)
                return "INTEGER_CURRENCY";

            if (value == DataTypeEnum.INTEGERMEASURE)
                return "INTEGER_MEASURE";

            if (value == DataTypeEnum.IRDI)
                return "IRDI";

            if (value == DataTypeEnum.IRI)
                return "IRI";

            if (value == DataTypeEnum.RATIONAL)
                return "RATIONAL";

            if (value == DataTypeEnum.RATIONALMEASURE)
                return "RATIONAL_MEASURE";

            if (value == DataTypeEnum.REALCOUNT)
                return "REAL_COUNT";

            if (value == DataTypeEnum.REALCURRENCY)
                return "REAL_CURRENCY";

            if (value == DataTypeEnum.REALMEASURE)
                return "REAL_MEASURE";

            if (value == DataTypeEnum.STRING)
                return "STRING";

            if (value == DataTypeEnum.STRINGTRANSLATABLE)
                return "STRING_TRANSLATABLE";

            if (value == DataTypeEnum.TIME)
                return "TIME";

            if (value == DataTypeEnum.TIMESTAMP)
                return "TIMESTAMP";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of DataType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DataTypeEnum?> DataTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets DataType
        /// </summary>
        [JsonPropertyName("dataType")]
        public DataTypeEnum? DataType { get { return this.DataTypeOption; } set { this.DataTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of PreferredName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<LangStringPreferredNameTypeIec61360>?> PreferredNameOption { get; private set; }

        /// <summary>
        /// Gets or Sets PreferredName
        /// </summary>
        [JsonPropertyName("preferredName")]
        public List<LangStringPreferredNameTypeIec61360>? PreferredName { get { return this.PreferredNameOption; } set { this.PreferredNameOption = new(value); } }

        /// <summary>
        /// Used to track the state of Value
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ValueOption { get; private set; }

        /// <summary>
        /// Gets or Sets Value
        /// </summary>
        [JsonPropertyName("value")]
        public string? Value { get { return this.ValueOption; } set { this.ValueOption = new(value); } }

        /// <summary>
        /// Used to track the state of Definition
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<LangStringDefinitionTypeIec61360>?> DefinitionOption { get; private set; }

        /// <summary>
        /// Gets or Sets Definition
        /// </summary>
        [JsonPropertyName("definition")]
        public List<LangStringDefinitionTypeIec61360>? Definition { get { return this.DefinitionOption; } set { this.DefinitionOption = new(value); } }

        /// <summary>
        /// Used to track the state of Symbol
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> SymbolOption { get; private set; }

        /// <summary>
        /// Gets or Sets Symbol
        /// </summary>
        [JsonPropertyName("symbol")]
        public string? Symbol { get { return this.SymbolOption; } set { this.SymbolOption = new(value); } }

        /// <summary>
        /// Used to track the state of ShortName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<LangStringShortNameTypeIec61360>?> ShortNameOption { get; private set; }

        /// <summary>
        /// Gets or Sets ShortName
        /// </summary>
        [JsonPropertyName("shortName")]
        public List<LangStringShortNameTypeIec61360>? ShortName { get { return this.ShortNameOption; } set { this.ShortNameOption = new(value); } }

        /// <summary>
        /// Used to track the state of Unit
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> UnitOption { get; private set; }

        /// <summary>
        /// Gets or Sets Unit
        /// </summary>
        [JsonPropertyName("unit")]
        public string? Unit { get { return this.UnitOption; } set { this.UnitOption = new(value); } }

        /// <summary>
        /// Used to track the state of UnitId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Reference?> UnitIdOption { get; private set; }

        /// <summary>
        /// Gets or Sets UnitId
        /// </summary>
        [JsonPropertyName("unitId")]
        public Reference? UnitId { get { return this.UnitIdOption; } set { this.UnitIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of SourceOfDefinition
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> SourceOfDefinitionOption { get; private set; }

        /// <summary>
        /// Gets or Sets SourceOfDefinition
        /// </summary>
        [JsonPropertyName("sourceOfDefinition")]
        public string? SourceOfDefinition { get { return this.SourceOfDefinitionOption; } set { this.SourceOfDefinitionOption = new(value); } }

        /// <summary>
        /// Used to track the state of ValueFormat
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ValueFormatOption { get; private set; }

        /// <summary>
        /// Gets or Sets ValueFormat
        /// </summary>
        [JsonPropertyName("valueFormat")]
        public string? ValueFormat { get { return this.ValueFormatOption; } set { this.ValueFormatOption = new(value); } }

        /// <summary>
        /// Used to track the state of ValueList
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ValueList?> ValueListOption { get; private set; }

        /// <summary>
        /// Gets or Sets ValueList
        /// </summary>
        [JsonPropertyName("valueList")]
        public ValueList? ValueList { get { return this.ValueListOption; } set { this.ValueListOption = new(value); } }

        /// <summary>
        /// Used to track the state of LevelType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<LevelType?> LevelTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets LevelType
        /// </summary>
        [JsonPropertyName("levelType")]
        public LevelType? LevelType { get { return this.LevelTypeOption; } set { this.LevelTypeOption = new(value); } }

        /// <summary>
        /// Gets or Sets additional properties
        /// </summary>
        [JsonExtensionData]
        public Dictionary<string, JsonElement> AdditionalProperties { get; } = new Dictionary<string, JsonElement>();

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DataSpecificationIec61360 {\n");
            sb.Append("  PreferredName: ").Append(PreferredName).Append("\n");
            sb.Append("  Value: ").Append(Value).Append("\n");
            sb.Append("  Definition: ").Append(Definition).Append("\n");
            sb.Append("  Symbol: ").Append(Symbol).Append("\n");
            sb.Append("  ShortName: ").Append(ShortName).Append("\n");
            sb.Append("  Unit: ").Append(Unit).Append("\n");
            sb.Append("  UnitId: ").Append(UnitId).Append("\n");
            sb.Append("  SourceOfDefinition: ").Append(SourceOfDefinition).Append("\n");
            sb.Append("  DataType: ").Append(DataType).Append("\n");
            sb.Append("  ValueFormat: ").Append(ValueFormat).Append("\n");
            sb.Append("  ValueList: ").Append(ValueList).Append("\n");
            sb.Append("  LevelType: ").Append(LevelType).Append("\n");
            sb.Append("  AdditionalProperties: ").Append(AdditionalProperties).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="DataSpecificationIec61360" />
    /// </summary>
    public class DataSpecificationIec61360JsonConverter : JsonConverter<DataSpecificationIec61360>
    {
        /// <summary>
        /// Deserializes json to <see cref="DataSpecificationIec61360" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override DataSpecificationIec61360 Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<List<LangStringPreferredNameTypeIec61360>?> preferredName = default;
            Option<string?> value = default;
            Option<List<LangStringDefinitionTypeIec61360>?> definition = default;
            Option<string?> symbol = default;
            Option<List<LangStringShortNameTypeIec61360>?> shortName = default;
            Option<string?> unit = default;
            Option<Reference?> unitId = default;
            Option<string?> sourceOfDefinition = default;
            Option<DataSpecificationIec61360.DataTypeEnum?> dataType = default;
            Option<string?> valueFormat = default;
            Option<ValueList?> valueList = default;
            Option<LevelType?> levelType = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "preferredName":
                            preferredName = new Option<List<LangStringPreferredNameTypeIec61360>?>(JsonSerializer.Deserialize<List<LangStringPreferredNameTypeIec61360>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "value":
                            value = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "definition":
                            definition = new Option<List<LangStringDefinitionTypeIec61360>?>(JsonSerializer.Deserialize<List<LangStringDefinitionTypeIec61360>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "symbol":
                            symbol = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "shortName":
                            shortName = new Option<List<LangStringShortNameTypeIec61360>?>(JsonSerializer.Deserialize<List<LangStringShortNameTypeIec61360>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "unit":
                            unit = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "unitId":
                            unitId = new Option<Reference?>(JsonSerializer.Deserialize<Reference>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "sourceOfDefinition":
                            sourceOfDefinition = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "dataType":
                            string? dataTypeRawValue = utf8JsonReader.GetString();
                            if (dataTypeRawValue != null)
                                dataType = new Option<DataSpecificationIec61360.DataTypeEnum?>(DataSpecificationIec61360.DataTypeEnumFromStringOrDefault(dataTypeRawValue));
                            break;
                        case "valueFormat":
                            valueFormat = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "valueList":
                            valueList = new Option<ValueList?>(JsonSerializer.Deserialize<ValueList>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "levelType":
                            levelType = new Option<LevelType?>(JsonSerializer.Deserialize<LevelType>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (preferredName.IsSet && preferredName.Value == null)
                throw new ArgumentNullException(nameof(preferredName), "Property is not nullable for class DataSpecificationIec61360.");

            if (value.IsSet && value.Value == null)
                throw new ArgumentNullException(nameof(value), "Property is not nullable for class DataSpecificationIec61360.");

            if (definition.IsSet && definition.Value == null)
                throw new ArgumentNullException(nameof(definition), "Property is not nullable for class DataSpecificationIec61360.");

            if (symbol.IsSet && symbol.Value == null)
                throw new ArgumentNullException(nameof(symbol), "Property is not nullable for class DataSpecificationIec61360.");

            if (shortName.IsSet && shortName.Value == null)
                throw new ArgumentNullException(nameof(shortName), "Property is not nullable for class DataSpecificationIec61360.");

            if (unit.IsSet && unit.Value == null)
                throw new ArgumentNullException(nameof(unit), "Property is not nullable for class DataSpecificationIec61360.");

            if (unitId.IsSet && unitId.Value == null)
                throw new ArgumentNullException(nameof(unitId), "Property is not nullable for class DataSpecificationIec61360.");

            if (sourceOfDefinition.IsSet && sourceOfDefinition.Value == null)
                throw new ArgumentNullException(nameof(sourceOfDefinition), "Property is not nullable for class DataSpecificationIec61360.");

            if (dataType.IsSet && dataType.Value == null)
                throw new ArgumentNullException(nameof(dataType), "Property is not nullable for class DataSpecificationIec61360.");

            if (valueFormat.IsSet && valueFormat.Value == null)
                throw new ArgumentNullException(nameof(valueFormat), "Property is not nullable for class DataSpecificationIec61360.");

            if (valueList.IsSet && valueList.Value == null)
                throw new ArgumentNullException(nameof(valueList), "Property is not nullable for class DataSpecificationIec61360.");

            if (levelType.IsSet && levelType.Value == null)
                throw new ArgumentNullException(nameof(levelType), "Property is not nullable for class DataSpecificationIec61360.");

            return new DataSpecificationIec61360(preferredName, value, definition, symbol, shortName, unit, unitId, sourceOfDefinition, dataType, valueFormat, valueList, levelType);
        }

        /// <summary>
        /// Serializes a <see cref="DataSpecificationIec61360" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="dataSpecificationIec61360"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, DataSpecificationIec61360 dataSpecificationIec61360, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, dataSpecificationIec61360, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="DataSpecificationIec61360" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="dataSpecificationIec61360"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, DataSpecificationIec61360 dataSpecificationIec61360, JsonSerializerOptions jsonSerializerOptions)
        {
            if (dataSpecificationIec61360.PreferredNameOption.IsSet && dataSpecificationIec61360.PreferredName == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.PreferredName), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.ValueOption.IsSet && dataSpecificationIec61360.Value == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.Value), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.DefinitionOption.IsSet && dataSpecificationIec61360.Definition == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.Definition), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.SymbolOption.IsSet && dataSpecificationIec61360.Symbol == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.Symbol), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.ShortNameOption.IsSet && dataSpecificationIec61360.ShortName == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.ShortName), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.UnitOption.IsSet && dataSpecificationIec61360.Unit == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.Unit), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.UnitIdOption.IsSet && dataSpecificationIec61360.UnitId == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.UnitId), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.SourceOfDefinitionOption.IsSet && dataSpecificationIec61360.SourceOfDefinition == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.SourceOfDefinition), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.ValueFormatOption.IsSet && dataSpecificationIec61360.ValueFormat == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.ValueFormat), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.ValueListOption.IsSet && dataSpecificationIec61360.ValueList == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.ValueList), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.LevelTypeOption.IsSet && dataSpecificationIec61360.LevelType == null)
                throw new ArgumentNullException(nameof(dataSpecificationIec61360.LevelType), "Property is required for class DataSpecificationIec61360.");

            if (dataSpecificationIec61360.PreferredNameOption.IsSet)
            {
                writer.WritePropertyName("preferredName");
                JsonSerializer.Serialize(writer, dataSpecificationIec61360.PreferredName, jsonSerializerOptions);
            }
            if (dataSpecificationIec61360.ValueOption.IsSet)
                writer.WriteString("value", dataSpecificationIec61360.Value);

            if (dataSpecificationIec61360.DefinitionOption.IsSet)
            {
                writer.WritePropertyName("definition");
                JsonSerializer.Serialize(writer, dataSpecificationIec61360.Definition, jsonSerializerOptions);
            }
            if (dataSpecificationIec61360.SymbolOption.IsSet)
                writer.WriteString("symbol", dataSpecificationIec61360.Symbol);

            if (dataSpecificationIec61360.ShortNameOption.IsSet)
            {
                writer.WritePropertyName("shortName");
                JsonSerializer.Serialize(writer, dataSpecificationIec61360.ShortName, jsonSerializerOptions);
            }
            if (dataSpecificationIec61360.UnitOption.IsSet)
                writer.WriteString("unit", dataSpecificationIec61360.Unit);

            if (dataSpecificationIec61360.UnitIdOption.IsSet)
            {
                writer.WritePropertyName("unitId");
                JsonSerializer.Serialize(writer, dataSpecificationIec61360.UnitId, jsonSerializerOptions);
            }
            if (dataSpecificationIec61360.SourceOfDefinitionOption.IsSet)
                writer.WriteString("sourceOfDefinition", dataSpecificationIec61360.SourceOfDefinition);

            var dataTypeRawValue = DataSpecificationIec61360.DataTypeEnumToJsonValue(dataSpecificationIec61360.DataTypeOption.Value!.Value);
            writer.WriteString("dataType", dataTypeRawValue);
            if (dataSpecificationIec61360.ValueFormatOption.IsSet)
                writer.WriteString("valueFormat", dataSpecificationIec61360.ValueFormat);

            if (dataSpecificationIec61360.ValueListOption.IsSet)
            {
                writer.WritePropertyName("valueList");
                JsonSerializer.Serialize(writer, dataSpecificationIec61360.ValueList, jsonSerializerOptions);
            }
            if (dataSpecificationIec61360.LevelTypeOption.IsSet)
            {
                writer.WritePropertyName("levelType");
                JsonSerializer.Serialize(writer, dataSpecificationIec61360.LevelType, jsonSerializerOptions);
            }
        }
    }
}
