// <auto-generated>
/*
 * BaSyx AAS Environment Component
 *
 * AAS Environment API
 *
 * The version of the OpenAPI document: 2.0
 * Contact: basyx-dev@eclipse.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using MnestixSearcher.Clients.Client;
using MnestixSearcher.Clients.Model;
using System.Diagnostics.CodeAnalysis;

namespace MnestixSearcher.Clients.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ISubmodelRepositoryAPIApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        SubmodelRepositoryAPIApiEvents Events { get; }

        /// <summary>
        /// Deletes a Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSubmodelByIdApiResponse"/>&gt;</returns>
        Task<IDeleteSubmodelByIdApiResponse> DeleteSubmodelByIdAsync(string submodelIdentifier, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes a Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSubmodelByIdApiResponse"/>?&gt;</returns>
        Task<IDeleteSubmodelByIdApiResponse?> DeleteSubmodelByIdOrDefaultAsync(string submodelIdentifier, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes a submodel element at a specified path within the submodel elements hierarchy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        Task<IDeleteSubmodelElementByPathSubmodelRepoApiResponse> DeleteSubmodelElementByPathSubmodelRepoAsync(string submodelIdentifier, string idShortPath, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes a submodel element at a specified path within the submodel elements hierarchy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSubmodelElementByPathSubmodelRepoApiResponse"/>?&gt;</returns>
        Task<IDeleteSubmodelElementByPathSubmodelRepoApiResponse?> DeleteSubmodelElementByPathSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns all submodel elements including their hierarchy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="limit">The maximum number of elements in the response array (optional)</param>
        /// <param name="cursor">A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue (optional)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllSubmodelElementsApiResponse"/>&gt;</returns>
        Task<IGetAllSubmodelElementsApiResponse> GetAllSubmodelElementsAsync(string submodelIdentifier, Option<string> limit = default, Option<Base64UrlEncodedCursor> cursor = default, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns all submodel elements including their hierarchy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="limit">The maximum number of elements in the response array (optional)</param>
        /// <param name="cursor">A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue (optional)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllSubmodelElementsApiResponse"/>?&gt;</returns>
        Task<IGetAllSubmodelElementsApiResponse?> GetAllSubmodelElementsOrDefaultAsync(string submodelIdentifier, Option<string> limit = default, Option<Base64UrlEncodedCursor> cursor = default, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns all Submodels
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticId">The value of the semantic id reference (UTF8-BASE64-URL-encoded) (optional)</param>
        /// <param name="idShort">The Asset Administration Shell’s IdShort (optional)</param>
        /// <param name="limit">The maximum number of elements in the response array (optional)</param>
        /// <param name="cursor">A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue (optional)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllSubmodelsApiResponse"/>&gt;</returns>
        Task<IGetAllSubmodelsApiResponse> GetAllSubmodelsAsync(Option<string> semanticId = default, Option<string> idShort = default, Option<string> limit = default, Option<Base64UrlEncodedCursor> cursor = default, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns all Submodels
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="semanticId">The value of the semantic id reference (UTF8-BASE64-URL-encoded) (optional)</param>
        /// <param name="idShort">The Asset Administration Shell’s IdShort (optional)</param>
        /// <param name="limit">The maximum number of elements in the response array (optional)</param>
        /// <param name="cursor">A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue (optional)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllSubmodelsApiResponse"/>?&gt;</returns>
        Task<IGetAllSubmodelsApiResponse?> GetAllSubmodelsOrDefaultAsync(Option<string> semanticId = default, Option<string> idShort = default, Option<string> limit = default, Option<Base64UrlEncodedCursor> cursor = default, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a specific Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdApiResponse"/>&gt;</returns>
        Task<IGetSubmodelByIdApiResponse> GetSubmodelByIdAsync(string submodelIdentifier, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a specific Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdApiResponse"/>?&gt;</returns>
        Task<IGetSubmodelByIdApiResponse?> GetSubmodelByIdOrDefaultAsync(string submodelIdentifier, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns the metadata attributes of a specific Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdMetadataApiResponse"/>&gt;</returns>
        Task<IGetSubmodelByIdMetadataApiResponse> GetSubmodelByIdMetadataAsync(string submodelIdentifier, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns the metadata attributes of a specific Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdMetadataApiResponse"/>?&gt;</returns>
        Task<IGetSubmodelByIdMetadataApiResponse?> GetSubmodelByIdMetadataOrDefaultAsync(string submodelIdentifier, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a specific Submodel in the ValueOnly representation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdValueOnlyApiResponse"/>&gt;</returns>
        Task<IGetSubmodelByIdValueOnlyApiResponse> GetSubmodelByIdValueOnlyAsync(string submodelIdentifier, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a specific Submodel in the ValueOnly representation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdValueOnlyApiResponse"/>?&gt;</returns>
        Task<IGetSubmodelByIdValueOnlyApiResponse?> GetSubmodelByIdValueOnlyOrDefaultAsync(string submodelIdentifier, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a specific submodel element from the Submodel at a specified path
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        Task<IGetSubmodelElementByPathSubmodelRepoApiResponse> GetSubmodelElementByPathSubmodelRepoAsync(string submodelIdentifier, string idShortPath, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a specific submodel element from the Submodel at a specified path
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelElementByPathSubmodelRepoApiResponse"/>?&gt;</returns>
        Task<IGetSubmodelElementByPathSubmodelRepoApiResponse?> GetSubmodelElementByPathSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>&gt;</returns>
        Task<IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse> GetSubmodelElementByPathValueOnlySubmodelRepoAsync(string submodelIdentifier, string idShortPath, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>?&gt;</returns>
        Task<IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse?> GetSubmodelElementByPathValueOnlySubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Synchronously or asynchronously invokes an Operation at a specified path
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="operationRequest"></param>
        /// <param name="async">Determines whether an operation invocation is performed asynchronously or synchronously (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInvokeOperationSubmodelRepoApiResponse"/>&gt;</returns>
        Task<IInvokeOperationSubmodelRepoApiResponse> InvokeOperationSubmodelRepoAsync(string submodelIdentifier, string idShortPath, OperationRequest operationRequest, Option<string> async = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Synchronously or asynchronously invokes an Operation at a specified path
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="operationRequest"></param>
        /// <param name="async">Determines whether an operation invocation is performed asynchronously or synchronously (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInvokeOperationSubmodelRepoApiResponse"/>?&gt;</returns>
        Task<IInvokeOperationSubmodelRepoApiResponse?> InvokeOperationSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, OperationRequest operationRequest, Option<string> async = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the values of an existing Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="patchSubmodelByIdValueOnlyRequestInner"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchSubmodelByIdValueOnlyApiResponse"/>&gt;</returns>
        Task<IPatchSubmodelByIdValueOnlyApiResponse> PatchSubmodelByIdValueOnlyAsync(string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the values of an existing Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="patchSubmodelByIdValueOnlyRequestInner"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchSubmodelByIdValueOnlyApiResponse"/>?&gt;</returns>
        Task<IPatchSubmodelByIdValueOnlyApiResponse?> PatchSubmodelByIdValueOnlyOrDefaultAsync(string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the value of an existing SubmodelElement
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="body"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>&gt;</returns>
        Task<IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse> PatchSubmodelElementByPathValueOnlySubmodelRepoAsync(string submodelIdentifier, string idShortPath, Object? body = default, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the value of an existing SubmodelElement
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="body"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>?&gt;</returns>
        Task<IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse?> PatchSubmodelElementByPathValueOnlySubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, Object? body = default, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a new Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodel"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelApiResponse"/>&gt;</returns>
        Task<IPostSubmodelApiResponse> PostSubmodelAsync(Submodel submodel, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a new Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodel"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelApiResponse"/>?&gt;</returns>
        Task<IPostSubmodelApiResponse?> PostSubmodelOrDefaultAsync(Submodel submodel, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a new submodel element at a specified path within submodel elements hierarchy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        Task<IPostSubmodelElementByPathSubmodelRepoApiResponse> PostSubmodelElementByPathSubmodelRepoAsync(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a new submodel element at a specified path within submodel elements hierarchy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelElementByPathSubmodelRepoApiResponse"/>?&gt;</returns>
        Task<IPostSubmodelElementByPathSubmodelRepoApiResponse?> PostSubmodelElementByPathSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a new submodel element
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelElementSubmodelRepoApiResponse"/>&gt;</returns>
        Task<IPostSubmodelElementSubmodelRepoApiResponse> PostSubmodelElementSubmodelRepoAsync(string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a new submodel element
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelElementSubmodelRepoApiResponse"/>?&gt;</returns>
        Task<IPostSubmodelElementSubmodelRepoApiResponse?> PostSubmodelElementSubmodelRepoOrDefaultAsync(string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates an existing Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="submodel"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutSubmodelByIdApiResponse"/>&gt;</returns>
        Task<IPutSubmodelByIdApiResponse> PutSubmodelByIdAsync(string submodelIdentifier, Submodel submodel, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates an existing Submodel
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="submodel"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutSubmodelByIdApiResponse"/>?&gt;</returns>
        Task<IPutSubmodelByIdApiResponse?> PutSubmodelByIdOrDefaultAsync(string submodelIdentifier, Submodel submodel, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates an existing submodel element at a specified path within submodel elements hierarchy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        Task<IPutSubmodelElementByPathSubmodelRepoApiResponse> PutSubmodelElementByPathSubmodelRepoAsync(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates an existing submodel element at a specified path within submodel elements hierarchy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutSubmodelElementByPathSubmodelRepoApiResponse"/>?&gt;</returns>
        Task<IPutSubmodelElementByPathSubmodelRepoApiResponse?> PutSubmodelElementByPathSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IDeleteSubmodelByIdApiResponse"/>
    /// </summary>
    public interface IDeleteSubmodelByIdApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>, IOk<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteSubmodelElementByPathSubmodelRepoApiResponse"/>
    /// </summary>
    public interface IDeleteSubmodelElementByPathSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>, IOk<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAllSubmodelElementsApiResponse"/>
    /// </summary>
    public interface IGetAllSubmodelElementsApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IOk<MnestixSearcher.Clients.Model.Result?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetAllSubmodelsApiResponse"/>
    /// </summary>
    public interface IGetAllSubmodelsApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IOk<MnestixSearcher.Clients.Model.Result?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetSubmodelByIdApiResponse"/>
    /// </summary>
    public interface IGetSubmodelByIdApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IOk<MnestixSearcher.Clients.Model.Submodel?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetSubmodelByIdMetadataApiResponse"/>
    /// </summary>
    public interface IGetSubmodelByIdMetadataApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IOk<MnestixSearcher.Clients.Model.Result?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetSubmodelByIdValueOnlyApiResponse"/>
    /// </summary>
    public interface IGetSubmodelByIdValueOnlyApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IOk<MnestixSearcher.Clients.Model.Result?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetSubmodelElementByPathSubmodelRepoApiResponse"/>
    /// </summary>
    public interface IGetSubmodelElementByPathSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IOk<MnestixSearcher.Clients.Model.Result?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>
    /// </summary>
    public interface IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IOk<MnestixSearcher.Clients.Model.Result?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IInvokeOperationSubmodelRepoApiResponse"/>
    /// </summary>
    public interface IInvokeOperationSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IOk<MnestixSearcher.Clients.Model.Result?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IMethodNotAllowed<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 405 MethodNotAllowed
        /// </summary>
        /// <returns></returns>
        bool IsMethodNotAllowed { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPatchSubmodelByIdValueOnlyApiResponse"/>
    /// </summary>
    public interface IPatchSubmodelByIdValueOnlyApiResponse : MnestixSearcher.Clients.Client.IApiResponse, INoContent<MnestixSearcher.Clients.Model.SubmodelValueOnly?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>
    /// </summary>
    public interface IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>, IOk<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IPostSubmodelApiResponse"/>
    /// </summary>
    public interface IPostSubmodelApiResponse : MnestixSearcher.Clients.Client.IApiResponse, ICreated<MnestixSearcher.Clients.Model.Submodel?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, IConflict<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>, IOk<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IPostSubmodelElementByPathSubmodelRepoApiResponse"/>
    /// </summary>
    public interface IPostSubmodelElementByPathSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.IApiResponse, ICreated<MnestixSearcher.Clients.Model.SubmodelElement?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IConflict<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>, IOk<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IPostSubmodelElementSubmodelRepoApiResponse"/>
    /// </summary>
    public interface IPostSubmodelElementSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.IApiResponse, ICreated<MnestixSearcher.Clients.Model.SubmodelElement?>, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IConflict<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>, IOk<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IPutSubmodelByIdApiResponse"/>
    /// </summary>
    public interface IPutSubmodelByIdApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>, IOk<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IPutSubmodelElementByPathSubmodelRepoApiResponse"/>
    /// </summary>
    public interface IPutSubmodelElementByPathSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.IApiResponse, IBadRequest<MnestixSearcher.Clients.Model.Result?>, IUnauthorized<MnestixSearcher.Clients.Model.Result?>, IForbidden<MnestixSearcher.Clients.Model.Result?>, INotFound<MnestixSearcher.Clients.Model.Result?>, IInternalServerError<MnestixSearcher.Clients.Model.Result?>, IOk<MnestixSearcher.Clients.Model.Result?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class SubmodelRepositoryAPIApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteSubmodelById;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteSubmodelById;

        internal void ExecuteOnDeleteSubmodelById(SubmodelRepositoryAPIApi.DeleteSubmodelByIdApiResponse apiResponse)
        {
            OnDeleteSubmodelById?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteSubmodelById(Exception exception)
        {
            OnErrorDeleteSubmodelById?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteSubmodelElementByPathSubmodelRepo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteSubmodelElementByPathSubmodelRepo;

        internal void ExecuteOnDeleteSubmodelElementByPathSubmodelRepo(SubmodelRepositoryAPIApi.DeleteSubmodelElementByPathSubmodelRepoApiResponse apiResponse)
        {
            OnDeleteSubmodelElementByPathSubmodelRepo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteSubmodelElementByPathSubmodelRepo(Exception exception)
        {
            OnErrorDeleteSubmodelElementByPathSubmodelRepo?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetAllSubmodelElements;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetAllSubmodelElements;

        internal void ExecuteOnGetAllSubmodelElements(SubmodelRepositoryAPIApi.GetAllSubmodelElementsApiResponse apiResponse)
        {
            OnGetAllSubmodelElements?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAllSubmodelElements(Exception exception)
        {
            OnErrorGetAllSubmodelElements?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetAllSubmodels;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetAllSubmodels;

        internal void ExecuteOnGetAllSubmodels(SubmodelRepositoryAPIApi.GetAllSubmodelsApiResponse apiResponse)
        {
            OnGetAllSubmodels?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAllSubmodels(Exception exception)
        {
            OnErrorGetAllSubmodels?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSubmodelById;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSubmodelById;

        internal void ExecuteOnGetSubmodelById(SubmodelRepositoryAPIApi.GetSubmodelByIdApiResponse apiResponse)
        {
            OnGetSubmodelById?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSubmodelById(Exception exception)
        {
            OnErrorGetSubmodelById?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSubmodelByIdMetadata;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSubmodelByIdMetadata;

        internal void ExecuteOnGetSubmodelByIdMetadata(SubmodelRepositoryAPIApi.GetSubmodelByIdMetadataApiResponse apiResponse)
        {
            OnGetSubmodelByIdMetadata?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSubmodelByIdMetadata(Exception exception)
        {
            OnErrorGetSubmodelByIdMetadata?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSubmodelByIdValueOnly;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSubmodelByIdValueOnly;

        internal void ExecuteOnGetSubmodelByIdValueOnly(SubmodelRepositoryAPIApi.GetSubmodelByIdValueOnlyApiResponse apiResponse)
        {
            OnGetSubmodelByIdValueOnly?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSubmodelByIdValueOnly(Exception exception)
        {
            OnErrorGetSubmodelByIdValueOnly?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSubmodelElementByPathSubmodelRepo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSubmodelElementByPathSubmodelRepo;

        internal void ExecuteOnGetSubmodelElementByPathSubmodelRepo(SubmodelRepositoryAPIApi.GetSubmodelElementByPathSubmodelRepoApiResponse apiResponse)
        {
            OnGetSubmodelElementByPathSubmodelRepo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSubmodelElementByPathSubmodelRepo(Exception exception)
        {
            OnErrorGetSubmodelElementByPathSubmodelRepo?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSubmodelElementByPathValueOnlySubmodelRepo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSubmodelElementByPathValueOnlySubmodelRepo;

        internal void ExecuteOnGetSubmodelElementByPathValueOnlySubmodelRepo(SubmodelRepositoryAPIApi.GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse apiResponse)
        {
            OnGetSubmodelElementByPathValueOnlySubmodelRepo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSubmodelElementByPathValueOnlySubmodelRepo(Exception exception)
        {
            OnErrorGetSubmodelElementByPathValueOnlySubmodelRepo?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInvokeOperationSubmodelRepo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInvokeOperationSubmodelRepo;

        internal void ExecuteOnInvokeOperationSubmodelRepo(SubmodelRepositoryAPIApi.InvokeOperationSubmodelRepoApiResponse apiResponse)
        {
            OnInvokeOperationSubmodelRepo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInvokeOperationSubmodelRepo(Exception exception)
        {
            OnErrorInvokeOperationSubmodelRepo?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPatchSubmodelByIdValueOnly;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPatchSubmodelByIdValueOnly;

        internal void ExecuteOnPatchSubmodelByIdValueOnly(SubmodelRepositoryAPIApi.PatchSubmodelByIdValueOnlyApiResponse apiResponse)
        {
            OnPatchSubmodelByIdValueOnly?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPatchSubmodelByIdValueOnly(Exception exception)
        {
            OnErrorPatchSubmodelByIdValueOnly?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPatchSubmodelElementByPathValueOnlySubmodelRepo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPatchSubmodelElementByPathValueOnlySubmodelRepo;

        internal void ExecuteOnPatchSubmodelElementByPathValueOnlySubmodelRepo(SubmodelRepositoryAPIApi.PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse apiResponse)
        {
            OnPatchSubmodelElementByPathValueOnlySubmodelRepo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPatchSubmodelElementByPathValueOnlySubmodelRepo(Exception exception)
        {
            OnErrorPatchSubmodelElementByPathValueOnlySubmodelRepo?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostSubmodel;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostSubmodel;

        internal void ExecuteOnPostSubmodel(SubmodelRepositoryAPIApi.PostSubmodelApiResponse apiResponse)
        {
            OnPostSubmodel?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostSubmodel(Exception exception)
        {
            OnErrorPostSubmodel?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostSubmodelElementByPathSubmodelRepo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostSubmodelElementByPathSubmodelRepo;

        internal void ExecuteOnPostSubmodelElementByPathSubmodelRepo(SubmodelRepositoryAPIApi.PostSubmodelElementByPathSubmodelRepoApiResponse apiResponse)
        {
            OnPostSubmodelElementByPathSubmodelRepo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostSubmodelElementByPathSubmodelRepo(Exception exception)
        {
            OnErrorPostSubmodelElementByPathSubmodelRepo?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostSubmodelElementSubmodelRepo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostSubmodelElementSubmodelRepo;

        internal void ExecuteOnPostSubmodelElementSubmodelRepo(SubmodelRepositoryAPIApi.PostSubmodelElementSubmodelRepoApiResponse apiResponse)
        {
            OnPostSubmodelElementSubmodelRepo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostSubmodelElementSubmodelRepo(Exception exception)
        {
            OnErrorPostSubmodelElementSubmodelRepo?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPutSubmodelById;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPutSubmodelById;

        internal void ExecuteOnPutSubmodelById(SubmodelRepositoryAPIApi.PutSubmodelByIdApiResponse apiResponse)
        {
            OnPutSubmodelById?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPutSubmodelById(Exception exception)
        {
            OnErrorPutSubmodelById?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPutSubmodelElementByPathSubmodelRepo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPutSubmodelElementByPathSubmodelRepo;

        internal void ExecuteOnPutSubmodelElementByPathSubmodelRepo(SubmodelRepositoryAPIApi.PutSubmodelElementByPathSubmodelRepoApiResponse apiResponse)
        {
            OnPutSubmodelElementByPathSubmodelRepo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPutSubmodelElementByPathSubmodelRepo(Exception exception)
        {
            OnErrorPutSubmodelElementByPathSubmodelRepo?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class SubmodelRepositoryAPIApi : ISubmodelRepositoryAPIApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<SubmodelRepositoryAPIApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public SubmodelRepositoryAPIApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SubmodelRepositoryAPIApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SubmodelRepositoryAPIApi(ILogger<SubmodelRepositoryAPIApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, SubmodelRepositoryAPIApiEvents submodelRepositoryAPIApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<SubmodelRepositoryAPIApi>();
            HttpClient = httpClient;
            Events = submodelRepositoryAPIApiEvents;
        }

        partial void FormatDeleteSubmodelById(ref string submodelIdentifier);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <returns></returns>
        private void ValidateDeleteSubmodelById(string submodelIdentifier)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        private void AfterDeleteSubmodelByIdDefaultImplementation(IDeleteSubmodelByIdApiResponse apiResponseLocalVar, string submodelIdentifier)
        {
            bool suppressDefaultLog = false;
            AfterDeleteSubmodelById(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        partial void AfterDeleteSubmodelById(ref bool suppressDefaultLog, IDeleteSubmodelByIdApiResponse apiResponseLocalVar, string submodelIdentifier);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        private void OnErrorDeleteSubmodelByIdDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteSubmodelById(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        partial void OnErrorDeleteSubmodelById(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier);

        /// <summary>
        /// Deletes a Submodel 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSubmodelByIdApiResponse"/>&gt;</returns>
        public async Task<IDeleteSubmodelByIdApiResponse?> DeleteSubmodelByIdOrDefaultAsync(string submodelIdentifier, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteSubmodelByIdAsync(submodelIdentifier, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Deletes a Submodel 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSubmodelByIdApiResponse"/>&gt;</returns>
        public async Task<IDeleteSubmodelByIdApiResponse> DeleteSubmodelByIdAsync(string submodelIdentifier, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteSubmodelById(submodelIdentifier);

                FormatDeleteSubmodelById(ref submodelIdentifier);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteSubmodelByIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteSubmodelByIdApiResponse>();

                        DeleteSubmodelByIdApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteSubmodelByIdDefaultImplementation(apiResponseLocalVar, submodelIdentifier);

                        Events.ExecuteOnDeleteSubmodelById(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteSubmodelByIdDefaultImplementation(e, "/submodels/{submodelIdentifier}", uriBuilderLocalVar.Path, submodelIdentifier);
                Events.ExecuteOnErrorDeleteSubmodelById(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteSubmodelByIdApiResponse"/>
        /// </summary>
        public partial class DeleteSubmodelByIdApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IDeleteSubmodelByIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteSubmodelByIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteSubmodelByIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteSubmodelByIdApiResponse(ILogger<DeleteSubmodelByIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteSubmodelElementByPathSubmodelRepo(ref string submodelIdentifier, ref string idShortPath);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <returns></returns>
        private void ValidateDeleteSubmodelElementByPathSubmodelRepo(string submodelIdentifier, string idShortPath)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (idShortPath == null)
                throw new ArgumentNullException(nameof(idShortPath));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        private void AfterDeleteSubmodelElementByPathSubmodelRepoDefaultImplementation(IDeleteSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath)
        {
            bool suppressDefaultLog = false;
            AfterDeleteSubmodelElementByPathSubmodelRepo(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, idShortPath);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        partial void AfterDeleteSubmodelElementByPathSubmodelRepo(ref bool suppressDefaultLog, IDeleteSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        private void OnErrorDeleteSubmodelElementByPathSubmodelRepoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteSubmodelElementByPathSubmodelRepo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, idShortPath);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        partial void OnErrorDeleteSubmodelElementByPathSubmodelRepo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath);

        /// <summary>
        /// Deletes a submodel element at a specified path within the submodel elements hierarchy 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IDeleteSubmodelElementByPathSubmodelRepoApiResponse?> DeleteSubmodelElementByPathSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteSubmodelElementByPathSubmodelRepoAsync(submodelIdentifier, idShortPath, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Deletes a submodel element at a specified path within the submodel elements hierarchy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IDeleteSubmodelElementByPathSubmodelRepoApiResponse> DeleteSubmodelElementByPathSubmodelRepoAsync(string submodelIdentifier, string idShortPath, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath);

                FormatDeleteSubmodelElementByPathSubmodelRepo(ref submodelIdentifier, ref idShortPath);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BidShortPath%7D", Uri.EscapeDataString(idShortPath.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteSubmodelElementByPathSubmodelRepoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteSubmodelElementByPathSubmodelRepoApiResponse>();

                        DeleteSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteSubmodelElementByPathSubmodelRepoDefaultImplementation(apiResponseLocalVar, submodelIdentifier, idShortPath);

                        Events.ExecuteOnDeleteSubmodelElementByPathSubmodelRepo(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteSubmodelElementByPathSubmodelRepoDefaultImplementation(e, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}", uriBuilderLocalVar.Path, submodelIdentifier, idShortPath);
                Events.ExecuteOnErrorDeleteSubmodelElementByPathSubmodelRepo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteSubmodelElementByPathSubmodelRepoApiResponse"/>
        /// </summary>
        public partial class DeleteSubmodelElementByPathSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IDeleteSubmodelElementByPathSubmodelRepoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteSubmodelElementByPathSubmodelRepoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteSubmodelElementByPathSubmodelRepoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteSubmodelElementByPathSubmodelRepoApiResponse(ILogger<DeleteSubmodelElementByPathSubmodelRepoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAllSubmodelElements(ref string submodelIdentifier, ref Option<string> limit, Option<Base64UrlEncodedCursor> cursor, ref Option<string> level, ref Option<string> extent);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        /// <returns></returns>
        private void ValidateGetAllSubmodelElements(string submodelIdentifier, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (limit.IsSet && limit.Value == null)
                throw new ArgumentNullException(nameof(limit));

            if (cursor.IsSet && cursor.Value == null)
                throw new ArgumentNullException(nameof(cursor));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));

            if (extent.IsSet && extent.Value == null)
                throw new ArgumentNullException(nameof(extent));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void AfterGetAllSubmodelElementsDefaultImplementation(IGetAllSubmodelElementsApiResponse apiResponseLocalVar, string submodelIdentifier, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLog = false;
            AfterGetAllSubmodelElements(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, limit, cursor, level, extent);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void AfterGetAllSubmodelElements(ref bool suppressDefaultLog, IGetAllSubmodelElementsApiResponse apiResponseLocalVar, string submodelIdentifier, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void OnErrorGetAllSubmodelElementsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAllSubmodelElements(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, limit, cursor, level, extent);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void OnErrorGetAllSubmodelElements(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent);

        /// <summary>
        /// Returns all submodel elements including their hierarchy 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="limit">The maximum number of elements in the response array (optional)</param>
        /// <param name="cursor">A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue (optional)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllSubmodelElementsApiResponse"/>&gt;</returns>
        public async Task<IGetAllSubmodelElementsApiResponse?> GetAllSubmodelElementsOrDefaultAsync(string submodelIdentifier, Option<string> limit = default, Option<Base64UrlEncodedCursor> cursor = default, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAllSubmodelElementsAsync(submodelIdentifier, limit, cursor, level, extent, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns all submodel elements including their hierarchy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="limit">The maximum number of elements in the response array (optional)</param>
        /// <param name="cursor">A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue (optional)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllSubmodelElementsApiResponse"/>&gt;</returns>
        public async Task<IGetAllSubmodelElementsApiResponse> GetAllSubmodelElementsAsync(string submodelIdentifier, Option<string> limit = default, Option<Base64UrlEncodedCursor> cursor = default, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAllSubmodelElements(submodelIdentifier, limit, cursor, level, extent);

                FormatGetAllSubmodelElements(ref submodelIdentifier, ref limit, cursor, ref level, ref extent);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/submodel-elements"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/submodel-elements");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (cursor.IsSet)
                        parseQueryStringLocalVar["cursor"] = ClientUtils.ParameterToString(cursor.Value);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    if (extent.IsSet)
                        parseQueryStringLocalVar["extent"] = ClientUtils.ParameterToString(extent.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetAllSubmodelElementsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAllSubmodelElementsApiResponse>();

                        GetAllSubmodelElementsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/submodel-elements", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAllSubmodelElementsDefaultImplementation(apiResponseLocalVar, submodelIdentifier, limit, cursor, level, extent);

                        Events.ExecuteOnGetAllSubmodelElements(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAllSubmodelElementsDefaultImplementation(e, "/submodels/{submodelIdentifier}/submodel-elements", uriBuilderLocalVar.Path, submodelIdentifier, limit, cursor, level, extent);
                Events.ExecuteOnErrorGetAllSubmodelElements(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAllSubmodelElementsApiResponse"/>
        /// </summary>
        public partial class GetAllSubmodelElementsApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IGetAllSubmodelElementsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAllSubmodelElementsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAllSubmodelElementsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAllSubmodelElementsApiResponse(ILogger<GetAllSubmodelElementsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAllSubmodels(ref Option<string> semanticId, ref Option<string> idShort, ref Option<string> limit, Option<Base64UrlEncodedCursor> cursor, ref Option<string> level, ref Option<string> extent);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="semanticId"></param>
        /// <param name="idShort"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        /// <returns></returns>
        private void ValidateGetAllSubmodels(Option<string> semanticId, Option<string> idShort, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent)
        {
            if (semanticId.IsSet && semanticId.Value == null)
                throw new ArgumentNullException(nameof(semanticId));

            if (idShort.IsSet && idShort.Value == null)
                throw new ArgumentNullException(nameof(idShort));

            if (limit.IsSet && limit.Value == null)
                throw new ArgumentNullException(nameof(limit));

            if (cursor.IsSet && cursor.Value == null)
                throw new ArgumentNullException(nameof(cursor));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));

            if (extent.IsSet && extent.Value == null)
                throw new ArgumentNullException(nameof(extent));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="semanticId"></param>
        /// <param name="idShort"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void AfterGetAllSubmodelsDefaultImplementation(IGetAllSubmodelsApiResponse apiResponseLocalVar, Option<string> semanticId, Option<string> idShort, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLog = false;
            AfterGetAllSubmodels(ref suppressDefaultLog, apiResponseLocalVar, semanticId, idShort, limit, cursor, level, extent);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="semanticId"></param>
        /// <param name="idShort"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void AfterGetAllSubmodels(ref bool suppressDefaultLog, IGetAllSubmodelsApiResponse apiResponseLocalVar, Option<string> semanticId, Option<string> idShort, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="semanticId"></param>
        /// <param name="idShort"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void OnErrorGetAllSubmodelsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> semanticId, Option<string> idShort, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAllSubmodels(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, semanticId, idShort, limit, cursor, level, extent);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="semanticId"></param>
        /// <param name="idShort"></param>
        /// <param name="limit"></param>
        /// <param name="cursor"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void OnErrorGetAllSubmodels(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> semanticId, Option<string> idShort, Option<string> limit, Option<Base64UrlEncodedCursor> cursor, Option<string> level, Option<string> extent);

        /// <summary>
        /// Returns all Submodels 
        /// </summary>
        /// <param name="semanticId">The value of the semantic id reference (UTF8-BASE64-URL-encoded) (optional)</param>
        /// <param name="idShort">The Asset Administration Shell’s IdShort (optional)</param>
        /// <param name="limit">The maximum number of elements in the response array (optional)</param>
        /// <param name="cursor">A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue (optional)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllSubmodelsApiResponse"/>&gt;</returns>
        public async Task<IGetAllSubmodelsApiResponse?> GetAllSubmodelsOrDefaultAsync(Option<string> semanticId = default, Option<string> idShort = default, Option<string> limit = default, Option<Base64UrlEncodedCursor> cursor = default, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAllSubmodelsAsync(semanticId, idShort, limit, cursor, level, extent, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns all Submodels 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticId">The value of the semantic id reference (UTF8-BASE64-URL-encoded) (optional)</param>
        /// <param name="idShort">The Asset Administration Shell’s IdShort (optional)</param>
        /// <param name="limit">The maximum number of elements in the response array (optional)</param>
        /// <param name="cursor">A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue (optional)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllSubmodelsApiResponse"/>&gt;</returns>
        public async Task<IGetAllSubmodelsApiResponse> GetAllSubmodelsAsync(Option<string> semanticId = default, Option<string> idShort = default, Option<string> limit = default, Option<Base64UrlEncodedCursor> cursor = default, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAllSubmodels(semanticId, idShort, limit, cursor, level, extent);

                FormatGetAllSubmodels(ref semanticId, ref idShort, ref limit, cursor, ref level, ref extent);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (semanticId.IsSet)
                        parseQueryStringLocalVar["semanticId"] = ClientUtils.ParameterToString(semanticId.Value);

                    if (idShort.IsSet)
                        parseQueryStringLocalVar["idShort"] = ClientUtils.ParameterToString(idShort.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (cursor.IsSet)
                        parseQueryStringLocalVar["cursor"] = ClientUtils.ParameterToString(cursor.Value);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    if (extent.IsSet)
                        parseQueryStringLocalVar["extent"] = ClientUtils.ParameterToString(extent.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetAllSubmodelsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAllSubmodelsApiResponse>();

                        GetAllSubmodelsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAllSubmodelsDefaultImplementation(apiResponseLocalVar, semanticId, idShort, limit, cursor, level, extent);

                        Events.ExecuteOnGetAllSubmodels(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAllSubmodelsDefaultImplementation(e, "/submodels", uriBuilderLocalVar.Path, semanticId, idShort, limit, cursor, level, extent);
                Events.ExecuteOnErrorGetAllSubmodels(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAllSubmodelsApiResponse"/>
        /// </summary>
        public partial class GetAllSubmodelsApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IGetAllSubmodelsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAllSubmodelsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAllSubmodelsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAllSubmodelsApiResponse(ILogger<GetAllSubmodelsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSubmodelById(ref string submodelIdentifier, ref Option<string> level, ref Option<string> extent);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        /// <returns></returns>
        private void ValidateGetSubmodelById(string submodelIdentifier, Option<string> level, Option<string> extent)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));

            if (extent.IsSet && extent.Value == null)
                throw new ArgumentNullException(nameof(extent));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void AfterGetSubmodelByIdDefaultImplementation(IGetSubmodelByIdApiResponse apiResponseLocalVar, string submodelIdentifier, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLog = false;
            AfterGetSubmodelById(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, level, extent);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void AfterGetSubmodelById(ref bool suppressDefaultLog, IGetSubmodelByIdApiResponse apiResponseLocalVar, string submodelIdentifier, Option<string> level, Option<string> extent);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void OnErrorGetSubmodelByIdDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSubmodelById(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, level, extent);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void OnErrorGetSubmodelById(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Option<string> level, Option<string> extent);

        /// <summary>
        /// Returns a specific Submodel 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelByIdApiResponse?> GetSubmodelByIdOrDefaultAsync(string submodelIdentifier, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSubmodelByIdAsync(submodelIdentifier, level, extent, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a specific Submodel 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelByIdApiResponse> GetSubmodelByIdAsync(string submodelIdentifier, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSubmodelById(submodelIdentifier, level, extent);

                FormatGetSubmodelById(ref submodelIdentifier, ref level, ref extent);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    if (extent.IsSet)
                        parseQueryStringLocalVar["extent"] = ClientUtils.ParameterToString(extent.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSubmodelByIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSubmodelByIdApiResponse>();

                        GetSubmodelByIdApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSubmodelByIdDefaultImplementation(apiResponseLocalVar, submodelIdentifier, level, extent);

                        Events.ExecuteOnGetSubmodelById(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSubmodelByIdDefaultImplementation(e, "/submodels/{submodelIdentifier}", uriBuilderLocalVar.Path, submodelIdentifier, level, extent);
                Events.ExecuteOnErrorGetSubmodelById(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSubmodelByIdApiResponse"/>
        /// </summary>
        public partial class GetSubmodelByIdApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IGetSubmodelByIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSubmodelByIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSubmodelByIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSubmodelByIdApiResponse(ILogger<GetSubmodelByIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Submodel? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Submodel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Submodel? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSubmodelByIdMetadata(ref string submodelIdentifier, ref Option<string> level);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <returns></returns>
        private void ValidateGetSubmodelByIdMetadata(string submodelIdentifier, Option<string> level)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        private void AfterGetSubmodelByIdMetadataDefaultImplementation(IGetSubmodelByIdMetadataApiResponse apiResponseLocalVar, string submodelIdentifier, Option<string> level)
        {
            bool suppressDefaultLog = false;
            AfterGetSubmodelByIdMetadata(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, level);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        partial void AfterGetSubmodelByIdMetadata(ref bool suppressDefaultLog, IGetSubmodelByIdMetadataApiResponse apiResponseLocalVar, string submodelIdentifier, Option<string> level);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        private void OnErrorGetSubmodelByIdMetadataDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Option<string> level)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSubmodelByIdMetadata(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, level);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        partial void OnErrorGetSubmodelByIdMetadata(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Option<string> level);

        /// <summary>
        /// Returns the metadata attributes of a specific Submodel 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdMetadataApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelByIdMetadataApiResponse?> GetSubmodelByIdMetadataOrDefaultAsync(string submodelIdentifier, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSubmodelByIdMetadataAsync(submodelIdentifier, level, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns the metadata attributes of a specific Submodel 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdMetadataApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelByIdMetadataApiResponse> GetSubmodelByIdMetadataAsync(string submodelIdentifier, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSubmodelByIdMetadata(submodelIdentifier, level);

                FormatGetSubmodelByIdMetadata(ref submodelIdentifier, ref level);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/$metadata"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/$metadata");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSubmodelByIdMetadataApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSubmodelByIdMetadataApiResponse>();

                        GetSubmodelByIdMetadataApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/$metadata", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSubmodelByIdMetadataDefaultImplementation(apiResponseLocalVar, submodelIdentifier, level);

                        Events.ExecuteOnGetSubmodelByIdMetadata(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSubmodelByIdMetadataDefaultImplementation(e, "/submodels/{submodelIdentifier}/$metadata", uriBuilderLocalVar.Path, submodelIdentifier, level);
                Events.ExecuteOnErrorGetSubmodelByIdMetadata(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSubmodelByIdMetadataApiResponse"/>
        /// </summary>
        public partial class GetSubmodelByIdMetadataApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IGetSubmodelByIdMetadataApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSubmodelByIdMetadataApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSubmodelByIdMetadataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSubmodelByIdMetadataApiResponse(ILogger<GetSubmodelByIdMetadataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSubmodelByIdValueOnly(ref string submodelIdentifier, ref Option<string> level, ref Option<string> extent);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        /// <returns></returns>
        private void ValidateGetSubmodelByIdValueOnly(string submodelIdentifier, Option<string> level, Option<string> extent)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));

            if (extent.IsSet && extent.Value == null)
                throw new ArgumentNullException(nameof(extent));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void AfterGetSubmodelByIdValueOnlyDefaultImplementation(IGetSubmodelByIdValueOnlyApiResponse apiResponseLocalVar, string submodelIdentifier, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLog = false;
            AfterGetSubmodelByIdValueOnly(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, level, extent);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void AfterGetSubmodelByIdValueOnly(ref bool suppressDefaultLog, IGetSubmodelByIdValueOnlyApiResponse apiResponseLocalVar, string submodelIdentifier, Option<string> level, Option<string> extent);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void OnErrorGetSubmodelByIdValueOnlyDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSubmodelByIdValueOnly(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, level, extent);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void OnErrorGetSubmodelByIdValueOnly(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Option<string> level, Option<string> extent);

        /// <summary>
        /// Returns a specific Submodel in the ValueOnly representation 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdValueOnlyApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelByIdValueOnlyApiResponse?> GetSubmodelByIdValueOnlyOrDefaultAsync(string submodelIdentifier, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSubmodelByIdValueOnlyAsync(submodelIdentifier, level, extent, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a specific Submodel in the ValueOnly representation 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelByIdValueOnlyApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelByIdValueOnlyApiResponse> GetSubmodelByIdValueOnlyAsync(string submodelIdentifier, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSubmodelByIdValueOnly(submodelIdentifier, level, extent);

                FormatGetSubmodelByIdValueOnly(ref submodelIdentifier, ref level, ref extent);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/$value"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/$value");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    if (extent.IsSet)
                        parseQueryStringLocalVar["extent"] = ClientUtils.ParameterToString(extent.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSubmodelByIdValueOnlyApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSubmodelByIdValueOnlyApiResponse>();

                        GetSubmodelByIdValueOnlyApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/$value", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSubmodelByIdValueOnlyDefaultImplementation(apiResponseLocalVar, submodelIdentifier, level, extent);

                        Events.ExecuteOnGetSubmodelByIdValueOnly(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSubmodelByIdValueOnlyDefaultImplementation(e, "/submodels/{submodelIdentifier}/$value", uriBuilderLocalVar.Path, submodelIdentifier, level, extent);
                Events.ExecuteOnErrorGetSubmodelByIdValueOnly(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSubmodelByIdValueOnlyApiResponse"/>
        /// </summary>
        public partial class GetSubmodelByIdValueOnlyApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IGetSubmodelByIdValueOnlyApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSubmodelByIdValueOnlyApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSubmodelByIdValueOnlyApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSubmodelByIdValueOnlyApiResponse(ILogger<GetSubmodelByIdValueOnlyApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSubmodelElementByPathSubmodelRepo(ref string submodelIdentifier, ref string idShortPath, ref Option<string> level, ref Option<string> extent);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        /// <returns></returns>
        private void ValidateGetSubmodelElementByPathSubmodelRepo(string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (idShortPath == null)
                throw new ArgumentNullException(nameof(idShortPath));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));

            if (extent.IsSet && extent.Value == null)
                throw new ArgumentNullException(nameof(extent));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void AfterGetSubmodelElementByPathSubmodelRepoDefaultImplementation(IGetSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLog = false;
            AfterGetSubmodelElementByPathSubmodelRepo(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, idShortPath, level, extent);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void AfterGetSubmodelElementByPathSubmodelRepo(ref bool suppressDefaultLog, IGetSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void OnErrorGetSubmodelElementByPathSubmodelRepoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSubmodelElementByPathSubmodelRepo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, idShortPath, level, extent);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void OnErrorGetSubmodelElementByPathSubmodelRepo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent);

        /// <summary>
        /// Returns a specific submodel element from the Submodel at a specified path 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelElementByPathSubmodelRepoApiResponse?> GetSubmodelElementByPathSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSubmodelElementByPathSubmodelRepoAsync(submodelIdentifier, idShortPath, level, extent, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a specific submodel element from the Submodel at a specified path 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelElementByPathSubmodelRepoApiResponse> GetSubmodelElementByPathSubmodelRepoAsync(string submodelIdentifier, string idShortPath, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath, level, extent);

                FormatGetSubmodelElementByPathSubmodelRepo(ref submodelIdentifier, ref idShortPath, ref level, ref extent);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BidShortPath%7D", Uri.EscapeDataString(idShortPath.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    if (extent.IsSet)
                        parseQueryStringLocalVar["extent"] = ClientUtils.ParameterToString(extent.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSubmodelElementByPathSubmodelRepoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSubmodelElementByPathSubmodelRepoApiResponse>();

                        GetSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSubmodelElementByPathSubmodelRepoDefaultImplementation(apiResponseLocalVar, submodelIdentifier, idShortPath, level, extent);

                        Events.ExecuteOnGetSubmodelElementByPathSubmodelRepo(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSubmodelElementByPathSubmodelRepoDefaultImplementation(e, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}", uriBuilderLocalVar.Path, submodelIdentifier, idShortPath, level, extent);
                Events.ExecuteOnErrorGetSubmodelElementByPathSubmodelRepo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSubmodelElementByPathSubmodelRepoApiResponse"/>
        /// </summary>
        public partial class GetSubmodelElementByPathSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IGetSubmodelElementByPathSubmodelRepoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSubmodelElementByPathSubmodelRepoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSubmodelElementByPathSubmodelRepoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSubmodelElementByPathSubmodelRepoApiResponse(ILogger<GetSubmodelElementByPathSubmodelRepoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSubmodelElementByPathValueOnlySubmodelRepo(ref string submodelIdentifier, ref string idShortPath, ref Option<string> level, ref Option<string> extent);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        /// <returns></returns>
        private void ValidateGetSubmodelElementByPathValueOnlySubmodelRepo(string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (idShortPath == null)
                throw new ArgumentNullException(nameof(idShortPath));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));

            if (extent.IsSet && extent.Value == null)
                throw new ArgumentNullException(nameof(extent));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void AfterGetSubmodelElementByPathValueOnlySubmodelRepoDefaultImplementation(IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLog = false;
            AfterGetSubmodelElementByPathValueOnlySubmodelRepo(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, idShortPath, level, extent);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void AfterGetSubmodelElementByPathValueOnlySubmodelRepo(ref bool suppressDefaultLog, IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void OnErrorGetSubmodelElementByPathValueOnlySubmodelRepoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSubmodelElementByPathValueOnlySubmodelRepo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, idShortPath, level, extent);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void OnErrorGetSubmodelElementByPathValueOnlySubmodelRepo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, Option<string> level, Option<string> extent);

        /// <summary>
        /// Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse?> GetSubmodelElementByPathValueOnlySubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSubmodelElementByPathValueOnlySubmodelRepoAsync(submodelIdentifier, idShortPath, level, extent, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse> GetSubmodelElementByPathValueOnlySubmodelRepoAsync(string submodelIdentifier, string idShortPath, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSubmodelElementByPathValueOnlySubmodelRepo(submodelIdentifier, idShortPath, level, extent);

                FormatGetSubmodelElementByPathValueOnlySubmodelRepo(ref submodelIdentifier, ref idShortPath, ref level, ref extent);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BidShortPath%7D", Uri.EscapeDataString(idShortPath.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    if (extent.IsSet)
                        parseQueryStringLocalVar["extent"] = ClientUtils.ParameterToString(extent.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse>();

                        GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSubmodelElementByPathValueOnlySubmodelRepoDefaultImplementation(apiResponseLocalVar, submodelIdentifier, idShortPath, level, extent);

                        Events.ExecuteOnGetSubmodelElementByPathValueOnlySubmodelRepo(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSubmodelElementByPathValueOnlySubmodelRepoDefaultImplementation(e, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value", uriBuilderLocalVar.Path, submodelIdentifier, idShortPath, level, extent);
                Events.ExecuteOnErrorGetSubmodelElementByPathValueOnlySubmodelRepo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>
        /// </summary>
        public partial class GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IGetSubmodelElementByPathValueOnlySubmodelRepoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse(ILogger<GetSubmodelElementByPathValueOnlySubmodelRepoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInvokeOperationSubmodelRepo(ref string submodelIdentifier, ref string idShortPath, OperationRequest operationRequest, ref Option<string> async);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="operationRequest"></param>
        /// <param name="async"></param>
        /// <returns></returns>
        private void ValidateInvokeOperationSubmodelRepo(string submodelIdentifier, string idShortPath, OperationRequest operationRequest, Option<string> async)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (idShortPath == null)
                throw new ArgumentNullException(nameof(idShortPath));

            if (operationRequest == null)
                throw new ArgumentNullException(nameof(operationRequest));

            if (async.IsSet && async.Value == null)
                throw new ArgumentNullException(nameof(async));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="operationRequest"></param>
        /// <param name="async"></param>
        private void AfterInvokeOperationSubmodelRepoDefaultImplementation(IInvokeOperationSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, OperationRequest operationRequest, Option<string> async)
        {
            bool suppressDefaultLog = false;
            AfterInvokeOperationSubmodelRepo(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, idShortPath, operationRequest, async);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="operationRequest"></param>
        /// <param name="async"></param>
        partial void AfterInvokeOperationSubmodelRepo(ref bool suppressDefaultLog, IInvokeOperationSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, OperationRequest operationRequest, Option<string> async);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="operationRequest"></param>
        /// <param name="async"></param>
        private void OnErrorInvokeOperationSubmodelRepoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, OperationRequest operationRequest, Option<string> async)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInvokeOperationSubmodelRepo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, idShortPath, operationRequest, async);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="operationRequest"></param>
        /// <param name="async"></param>
        partial void OnErrorInvokeOperationSubmodelRepo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, OperationRequest operationRequest, Option<string> async);

        /// <summary>
        /// Synchronously or asynchronously invokes an Operation at a specified path 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="operationRequest"></param>
        /// <param name="async">Determines whether an operation invocation is performed asynchronously or synchronously (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInvokeOperationSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IInvokeOperationSubmodelRepoApiResponse?> InvokeOperationSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, OperationRequest operationRequest, Option<string> async = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InvokeOperationSubmodelRepoAsync(submodelIdentifier, idShortPath, operationRequest, async, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Synchronously or asynchronously invokes an Operation at a specified path 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="operationRequest"></param>
        /// <param name="async">Determines whether an operation invocation is performed asynchronously or synchronously (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInvokeOperationSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IInvokeOperationSubmodelRepoApiResponse> InvokeOperationSubmodelRepoAsync(string submodelIdentifier, string idShortPath, OperationRequest operationRequest, Option<string> async = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInvokeOperationSubmodelRepo(submodelIdentifier, idShortPath, operationRequest, async);

                FormatInvokeOperationSubmodelRepo(ref submodelIdentifier, ref idShortPath, operationRequest, ref async);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BidShortPath%7D", Uri.EscapeDataString(idShortPath.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (async.IsSet)
                        parseQueryStringLocalVar["async"] = ClientUtils.ParameterToString(async.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (operationRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(operationRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<InvokeOperationSubmodelRepoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InvokeOperationSubmodelRepoApiResponse>();

                        InvokeOperationSubmodelRepoApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterInvokeOperationSubmodelRepoDefaultImplementation(apiResponseLocalVar, submodelIdentifier, idShortPath, operationRequest, async);

                        Events.ExecuteOnInvokeOperationSubmodelRepo(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInvokeOperationSubmodelRepoDefaultImplementation(e, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke", uriBuilderLocalVar.Path, submodelIdentifier, idShortPath, operationRequest, async);
                Events.ExecuteOnErrorInvokeOperationSubmodelRepo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InvokeOperationSubmodelRepoApiResponse"/>
        /// </summary>
        public partial class InvokeOperationSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IInvokeOperationSubmodelRepoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InvokeOperationSubmodelRepoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InvokeOperationSubmodelRepoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InvokeOperationSubmodelRepoApiResponse(ILogger<InvokeOperationSubmodelRepoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 405 MethodNotAllowed
            /// </summary>
            /// <returns></returns>
            public bool IsMethodNotAllowed => 405 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 405 MethodNotAllowed
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? MethodNotAllowed()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsMethodNotAllowed
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 405 MethodNotAllowed and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryMethodNotAllowed([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = MethodNotAllowed();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)405);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPatchSubmodelByIdValueOnly(ref string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, ref Option<string> level);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="patchSubmodelByIdValueOnlyRequestInner"></param>
        /// <param name="level"></param>
        /// <returns></returns>
        private void ValidatePatchSubmodelByIdValueOnly(string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, Option<string> level)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (patchSubmodelByIdValueOnlyRequestInner == null)
                throw new ArgumentNullException(nameof(patchSubmodelByIdValueOnlyRequestInner));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="patchSubmodelByIdValueOnlyRequestInner"></param>
        /// <param name="level"></param>
        private void AfterPatchSubmodelByIdValueOnlyDefaultImplementation(IPatchSubmodelByIdValueOnlyApiResponse apiResponseLocalVar, string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, Option<string> level)
        {
            bool suppressDefaultLog = false;
            AfterPatchSubmodelByIdValueOnly(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, patchSubmodelByIdValueOnlyRequestInner, level);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="patchSubmodelByIdValueOnlyRequestInner"></param>
        /// <param name="level"></param>
        partial void AfterPatchSubmodelByIdValueOnly(ref bool suppressDefaultLog, IPatchSubmodelByIdValueOnlyApiResponse apiResponseLocalVar, string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, Option<string> level);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="patchSubmodelByIdValueOnlyRequestInner"></param>
        /// <param name="level"></param>
        private void OnErrorPatchSubmodelByIdValueOnlyDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, Option<string> level)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPatchSubmodelByIdValueOnly(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, patchSubmodelByIdValueOnlyRequestInner, level);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="patchSubmodelByIdValueOnlyRequestInner"></param>
        /// <param name="level"></param>
        partial void OnErrorPatchSubmodelByIdValueOnly(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, Option<string> level);

        /// <summary>
        /// Updates the values of an existing Submodel 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="patchSubmodelByIdValueOnlyRequestInner"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchSubmodelByIdValueOnlyApiResponse"/>&gt;</returns>
        public async Task<IPatchSubmodelByIdValueOnlyApiResponse?> PatchSubmodelByIdValueOnlyOrDefaultAsync(string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PatchSubmodelByIdValueOnlyAsync(submodelIdentifier, patchSubmodelByIdValueOnlyRequestInner, level, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates the values of an existing Submodel 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="patchSubmodelByIdValueOnlyRequestInner"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchSubmodelByIdValueOnlyApiResponse"/>&gt;</returns>
        public async Task<IPatchSubmodelByIdValueOnlyApiResponse> PatchSubmodelByIdValueOnlyAsync(string submodelIdentifier, List<PatchSubmodelByIdValueOnlyRequestInner> patchSubmodelByIdValueOnlyRequestInner, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePatchSubmodelByIdValueOnly(submodelIdentifier, patchSubmodelByIdValueOnlyRequestInner, level);

                FormatPatchSubmodelByIdValueOnly(ref submodelIdentifier, patchSubmodelByIdValueOnlyRequestInner, ref level);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/$value"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/$value");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (patchSubmodelByIdValueOnlyRequestInner as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchSubmodelByIdValueOnlyRequestInner, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PatchSubmodelByIdValueOnlyApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PatchSubmodelByIdValueOnlyApiResponse>();

                        PatchSubmodelByIdValueOnlyApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/$value", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPatchSubmodelByIdValueOnlyDefaultImplementation(apiResponseLocalVar, submodelIdentifier, patchSubmodelByIdValueOnlyRequestInner, level);

                        Events.ExecuteOnPatchSubmodelByIdValueOnly(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPatchSubmodelByIdValueOnlyDefaultImplementation(e, "/submodels/{submodelIdentifier}/$value", uriBuilderLocalVar.Path, submodelIdentifier, patchSubmodelByIdValueOnlyRequestInner, level);
                Events.ExecuteOnErrorPatchSubmodelByIdValueOnly(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PatchSubmodelByIdValueOnlyApiResponse"/>
        /// </summary>
        public partial class PatchSubmodelByIdValueOnlyApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IPatchSubmodelByIdValueOnlyApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PatchSubmodelByIdValueOnlyApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PatchSubmodelByIdValueOnlyApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PatchSubmodelByIdValueOnlyApiResponse(ILogger<PatchSubmodelByIdValueOnlyApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.SubmodelValueOnly? NoContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNoContent
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.SubmodelValueOnly>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 204 NoContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNoContent([NotNullWhen(true)]out MnestixSearcher.Clients.Model.SubmodelValueOnly? result)
            {
                result = null;

                try
                {
                    result = NoContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)204);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPatchSubmodelElementByPathValueOnlySubmodelRepo(ref string submodelIdentifier, ref string idShortPath, ref Object? body, ref Option<string> level);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="level"></param>
        /// <returns></returns>
        private void ValidatePatchSubmodelElementByPathValueOnlySubmodelRepo(string submodelIdentifier, string idShortPath, Option<string> level)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (idShortPath == null)
                throw new ArgumentNullException(nameof(idShortPath));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="body"></param>
        /// <param name="level"></param>
        private void AfterPatchSubmodelElementByPathValueOnlySubmodelRepoDefaultImplementation(IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, Object? body, Option<string> level)
        {
            bool suppressDefaultLog = false;
            AfterPatchSubmodelElementByPathValueOnlySubmodelRepo(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, idShortPath, body, level);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="body"></param>
        /// <param name="level"></param>
        partial void AfterPatchSubmodelElementByPathValueOnlySubmodelRepo(ref bool suppressDefaultLog, IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, Object? body, Option<string> level);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="body"></param>
        /// <param name="level"></param>
        private void OnErrorPatchSubmodelElementByPathValueOnlySubmodelRepoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, Object? body, Option<string> level)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPatchSubmodelElementByPathValueOnlySubmodelRepo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, idShortPath, body, level);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="body"></param>
        /// <param name="level"></param>
        partial void OnErrorPatchSubmodelElementByPathValueOnlySubmodelRepo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, Object? body, Option<string> level);

        /// <summary>
        /// Updates the value of an existing SubmodelElement 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="body"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse?> PatchSubmodelElementByPathValueOnlySubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, Object? body = default, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PatchSubmodelElementByPathValueOnlySubmodelRepoAsync(submodelIdentifier, idShortPath, body, level, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates the value of an existing SubmodelElement 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="body"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse> PatchSubmodelElementByPathValueOnlySubmodelRepoAsync(string submodelIdentifier, string idShortPath, Object? body = default, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePatchSubmodelElementByPathValueOnlySubmodelRepo(submodelIdentifier, idShortPath, level);

                FormatPatchSubmodelElementByPathValueOnlySubmodelRepo(ref submodelIdentifier, ref idShortPath, ref body, ref level);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BidShortPath%7D", Uri.EscapeDataString(idShortPath.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (body as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse>();

                        PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPatchSubmodelElementByPathValueOnlySubmodelRepoDefaultImplementation(apiResponseLocalVar, submodelIdentifier, idShortPath, body, level);

                        Events.ExecuteOnPatchSubmodelElementByPathValueOnlySubmodelRepo(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPatchSubmodelElementByPathValueOnlySubmodelRepoDefaultImplementation(e, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value", uriBuilderLocalVar.Path, submodelIdentifier, idShortPath, body, level);
                Events.ExecuteOnErrorPatchSubmodelElementByPathValueOnlySubmodelRepo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>
        /// </summary>
        public partial class PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IPatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse(ILogger<PatchSubmodelElementByPathValueOnlySubmodelRepoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostSubmodel(Submodel submodel);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodel"></param>
        /// <returns></returns>
        private void ValidatePostSubmodel(Submodel submodel)
        {
            if (submodel == null)
                throw new ArgumentNullException(nameof(submodel));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodel"></param>
        private void AfterPostSubmodelDefaultImplementation(IPostSubmodelApiResponse apiResponseLocalVar, Submodel submodel)
        {
            bool suppressDefaultLog = false;
            AfterPostSubmodel(ref suppressDefaultLog, apiResponseLocalVar, submodel);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodel"></param>
        partial void AfterPostSubmodel(ref bool suppressDefaultLog, IPostSubmodelApiResponse apiResponseLocalVar, Submodel submodel);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodel"></param>
        private void OnErrorPostSubmodelDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Submodel submodel)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPostSubmodel(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodel);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodel"></param>
        partial void OnErrorPostSubmodel(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Submodel submodel);

        /// <summary>
        /// Creates a new Submodel 
        /// </summary>
        /// <param name="submodel"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelApiResponse"/>&gt;</returns>
        public async Task<IPostSubmodelApiResponse?> PostSubmodelOrDefaultAsync(Submodel submodel, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostSubmodelAsync(submodel, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Creates a new Submodel 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodel"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelApiResponse"/>&gt;</returns>
        public async Task<IPostSubmodelApiResponse> PostSubmodelAsync(Submodel submodel, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostSubmodel(submodel);

                FormatPostSubmodel(submodel);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels");

                    httpRequestMessageLocalVar.Content = (submodel as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(submodel, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostSubmodelApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostSubmodelApiResponse>();

                        PostSubmodelApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostSubmodelDefaultImplementation(apiResponseLocalVar, submodel);

                        Events.ExecuteOnPostSubmodel(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostSubmodelDefaultImplementation(e, "/submodels", uriBuilderLocalVar.Path, submodel);
                Events.ExecuteOnErrorPostSubmodel(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostSubmodelApiResponse"/>
        /// </summary>
        public partial class PostSubmodelApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IPostSubmodelApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostSubmodelApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostSubmodelApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostSubmodelApiResponse(ILogger<PostSubmodelApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Submodel? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Submodel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Submodel? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostSubmodelElementByPathSubmodelRepo(ref string submodelIdentifier, ref string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, ref Option<string> level, ref Option<string> extent);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        /// <returns></returns>
        private void ValidatePostSubmodelElementByPathSubmodelRepo(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level, Option<string> extent)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (idShortPath == null)
                throw new ArgumentNullException(nameof(idShortPath));

            if (putSubmodelElementByPathSubmodelRepoRequest == null)
                throw new ArgumentNullException(nameof(putSubmodelElementByPathSubmodelRepoRequest));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));

            if (extent.IsSet && extent.Value == null)
                throw new ArgumentNullException(nameof(extent));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void AfterPostSubmodelElementByPathSubmodelRepoDefaultImplementation(IPostSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLog = false;
            AfterPostSubmodelElementByPathSubmodelRepo(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level, extent);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void AfterPostSubmodelElementByPathSubmodelRepo(ref bool suppressDefaultLog, IPostSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level, Option<string> extent);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        private void OnErrorPostSubmodelElementByPathSubmodelRepoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level, Option<string> extent)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPostSubmodelElementByPathSubmodelRepo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level, extent);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        /// <param name="extent"></param>
        partial void OnErrorPostSubmodelElementByPathSubmodelRepo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level, Option<string> extent);

        /// <summary>
        /// Creates a new submodel element at a specified path within submodel elements hierarchy 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IPostSubmodelElementByPathSubmodelRepoApiResponse?> PostSubmodelElementByPathSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostSubmodelElementByPathSubmodelRepoAsync(submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level, extent, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Creates a new submodel element at a specified path within submodel elements hierarchy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="extent">Determines to which extent the resource is being serialized (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IPostSubmodelElementByPathSubmodelRepoApiResponse> PostSubmodelElementByPathSubmodelRepoAsync(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level = default, Option<string> extent = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level, extent);

                FormatPostSubmodelElementByPathSubmodelRepo(ref submodelIdentifier, ref idShortPath, putSubmodelElementByPathSubmodelRepoRequest, ref level, ref extent);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BidShortPath%7D", Uri.EscapeDataString(idShortPath.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    if (extent.IsSet)
                        parseQueryStringLocalVar["extent"] = ClientUtils.ParameterToString(extent.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (putSubmodelElementByPathSubmodelRepoRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(putSubmodelElementByPathSubmodelRepoRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostSubmodelElementByPathSubmodelRepoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostSubmodelElementByPathSubmodelRepoApiResponse>();

                        PostSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostSubmodelElementByPathSubmodelRepoDefaultImplementation(apiResponseLocalVar, submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level, extent);

                        Events.ExecuteOnPostSubmodelElementByPathSubmodelRepo(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostSubmodelElementByPathSubmodelRepoDefaultImplementation(e, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}", uriBuilderLocalVar.Path, submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level, extent);
                Events.ExecuteOnErrorPostSubmodelElementByPathSubmodelRepo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostSubmodelElementByPathSubmodelRepoApiResponse"/>
        /// </summary>
        public partial class PostSubmodelElementByPathSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IPostSubmodelElementByPathSubmodelRepoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostSubmodelElementByPathSubmodelRepoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostSubmodelElementByPathSubmodelRepoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostSubmodelElementByPathSubmodelRepoApiResponse(ILogger<PostSubmodelElementByPathSubmodelRepoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.SubmodelElement? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.SubmodelElement>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out MnestixSearcher.Clients.Model.SubmodelElement? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostSubmodelElementSubmodelRepo(ref string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <returns></returns>
        private void ValidatePostSubmodelElementSubmodelRepo(string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (putSubmodelElementByPathSubmodelRepoRequest == null)
                throw new ArgumentNullException(nameof(putSubmodelElementByPathSubmodelRepoRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        private void AfterPostSubmodelElementSubmodelRepoDefaultImplementation(IPostSubmodelElementSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest)
        {
            bool suppressDefaultLog = false;
            AfterPostSubmodelElementSubmodelRepo(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, putSubmodelElementByPathSubmodelRepoRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        partial void AfterPostSubmodelElementSubmodelRepo(ref bool suppressDefaultLog, IPostSubmodelElementSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        private void OnErrorPostSubmodelElementSubmodelRepoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPostSubmodelElementSubmodelRepo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, putSubmodelElementByPathSubmodelRepoRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        partial void OnErrorPostSubmodelElementSubmodelRepo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest);

        /// <summary>
        /// Creates a new submodel element 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelElementSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IPostSubmodelElementSubmodelRepoApiResponse?> PostSubmodelElementSubmodelRepoOrDefaultAsync(string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostSubmodelElementSubmodelRepoAsync(submodelIdentifier, putSubmodelElementByPathSubmodelRepoRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Creates a new submodel element 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostSubmodelElementSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IPostSubmodelElementSubmodelRepoApiResponse> PostSubmodelElementSubmodelRepoAsync(string submodelIdentifier, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostSubmodelElementSubmodelRepo(submodelIdentifier, putSubmodelElementByPathSubmodelRepoRequest);

                FormatPostSubmodelElementSubmodelRepo(ref submodelIdentifier, putSubmodelElementByPathSubmodelRepoRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/submodel-elements"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/submodel-elements");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));

                    httpRequestMessageLocalVar.Content = (putSubmodelElementByPathSubmodelRepoRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(putSubmodelElementByPathSubmodelRepoRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostSubmodelElementSubmodelRepoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostSubmodelElementSubmodelRepoApiResponse>();

                        PostSubmodelElementSubmodelRepoApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/submodel-elements", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostSubmodelElementSubmodelRepoDefaultImplementation(apiResponseLocalVar, submodelIdentifier, putSubmodelElementByPathSubmodelRepoRequest);

                        Events.ExecuteOnPostSubmodelElementSubmodelRepo(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostSubmodelElementSubmodelRepoDefaultImplementation(e, "/submodels/{submodelIdentifier}/submodel-elements", uriBuilderLocalVar.Path, submodelIdentifier, putSubmodelElementByPathSubmodelRepoRequest);
                Events.ExecuteOnErrorPostSubmodelElementSubmodelRepo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostSubmodelElementSubmodelRepoApiResponse"/>
        /// </summary>
        public partial class PostSubmodelElementSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IPostSubmodelElementSubmodelRepoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostSubmodelElementSubmodelRepoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostSubmodelElementSubmodelRepoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostSubmodelElementSubmodelRepoApiResponse(ILogger<PostSubmodelElementSubmodelRepoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.SubmodelElement? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.SubmodelElement>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out MnestixSearcher.Clients.Model.SubmodelElement? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPutSubmodelById(ref string submodelIdentifier, Submodel submodel, ref Option<string> level);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="submodel"></param>
        /// <param name="level"></param>
        /// <returns></returns>
        private void ValidatePutSubmodelById(string submodelIdentifier, Submodel submodel, Option<string> level)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (submodel == null)
                throw new ArgumentNullException(nameof(submodel));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="submodel"></param>
        /// <param name="level"></param>
        private void AfterPutSubmodelByIdDefaultImplementation(IPutSubmodelByIdApiResponse apiResponseLocalVar, string submodelIdentifier, Submodel submodel, Option<string> level)
        {
            bool suppressDefaultLog = false;
            AfterPutSubmodelById(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, submodel, level);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="submodel"></param>
        /// <param name="level"></param>
        partial void AfterPutSubmodelById(ref bool suppressDefaultLog, IPutSubmodelByIdApiResponse apiResponseLocalVar, string submodelIdentifier, Submodel submodel, Option<string> level);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="submodel"></param>
        /// <param name="level"></param>
        private void OnErrorPutSubmodelByIdDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Submodel submodel, Option<string> level)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPutSubmodelById(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, submodel, level);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="submodel"></param>
        /// <param name="level"></param>
        partial void OnErrorPutSubmodelById(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, Submodel submodel, Option<string> level);

        /// <summary>
        /// Updates an existing Submodel 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="submodel"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutSubmodelByIdApiResponse"/>&gt;</returns>
        public async Task<IPutSubmodelByIdApiResponse?> PutSubmodelByIdOrDefaultAsync(string submodelIdentifier, Submodel submodel, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PutSubmodelByIdAsync(submodelIdentifier, submodel, level, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates an existing Submodel 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="submodel"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutSubmodelByIdApiResponse"/>&gt;</returns>
        public async Task<IPutSubmodelByIdApiResponse> PutSubmodelByIdAsync(string submodelIdentifier, Submodel submodel, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePutSubmodelById(submodelIdentifier, submodel, level);

                FormatPutSubmodelById(ref submodelIdentifier, submodel, ref level);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (submodel as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(submodel, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PutSubmodelByIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PutSubmodelByIdApiResponse>();

                        PutSubmodelByIdApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPutSubmodelByIdDefaultImplementation(apiResponseLocalVar, submodelIdentifier, submodel, level);

                        Events.ExecuteOnPutSubmodelById(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPutSubmodelByIdDefaultImplementation(e, "/submodels/{submodelIdentifier}", uriBuilderLocalVar.Path, submodelIdentifier, submodel, level);
                Events.ExecuteOnErrorPutSubmodelById(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PutSubmodelByIdApiResponse"/>
        /// </summary>
        public partial class PutSubmodelByIdApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IPutSubmodelByIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PutSubmodelByIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PutSubmodelByIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PutSubmodelByIdApiResponse(ILogger<PutSubmodelByIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPutSubmodelElementByPathSubmodelRepo(ref string submodelIdentifier, ref string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, ref Option<string> level);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        /// <returns></returns>
        private void ValidatePutSubmodelElementByPathSubmodelRepo(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level)
        {
            if (submodelIdentifier == null)
                throw new ArgumentNullException(nameof(submodelIdentifier));

            if (idShortPath == null)
                throw new ArgumentNullException(nameof(idShortPath));

            if (putSubmodelElementByPathSubmodelRepoRequest == null)
                throw new ArgumentNullException(nameof(putSubmodelElementByPathSubmodelRepoRequest));

            if (level.IsSet && level.Value == null)
                throw new ArgumentNullException(nameof(level));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        private void AfterPutSubmodelElementByPathSubmodelRepoDefaultImplementation(IPutSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level)
        {
            bool suppressDefaultLog = false;
            AfterPutSubmodelElementByPathSubmodelRepo(ref suppressDefaultLog, apiResponseLocalVar, submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        partial void AfterPutSubmodelElementByPathSubmodelRepo(ref bool suppressDefaultLog, IPutSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar, string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        private void OnErrorPutSubmodelElementByPathSubmodelRepoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPutSubmodelElementByPathSubmodelRepo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="submodelIdentifier"></param>
        /// <param name="idShortPath"></param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level"></param>
        partial void OnErrorPutSubmodelElementByPathSubmodelRepo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level);

        /// <summary>
        /// Updates an existing submodel element at a specified path within submodel elements hierarchy 
        /// </summary>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IPutSubmodelElementByPathSubmodelRepoApiResponse?> PutSubmodelElementByPathSubmodelRepoOrDefaultAsync(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PutSubmodelElementByPathSubmodelRepoAsync(submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates an existing submodel element at a specified path within submodel elements hierarchy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submodelIdentifier">The Submodel’s unique id (UTF8-BASE64-URL-encoded)</param>
        /// <param name="idShortPath">IdShort path to the submodel element (dot-separated)</param>
        /// <param name="putSubmodelElementByPathSubmodelRepoRequest"></param>
        /// <param name="level">Determines the structural depth of the respective resource content (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutSubmodelElementByPathSubmodelRepoApiResponse"/>&gt;</returns>
        public async Task<IPutSubmodelElementByPathSubmodelRepoApiResponse> PutSubmodelElementByPathSubmodelRepoAsync(string submodelIdentifier, string idShortPath, PutSubmodelElementByPathSubmodelRepoRequest putSubmodelElementByPathSubmodelRepoRequest, Option<string> level = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePutSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level);

                FormatPutSubmodelElementByPathSubmodelRepo(ref submodelIdentifier, ref idShortPath, putSubmodelElementByPathSubmodelRepoRequest, ref level);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BsubmodelIdentifier%7D", Uri.EscapeDataString(submodelIdentifier.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BidShortPath%7D", Uri.EscapeDataString(idShortPath.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (level.IsSet)
                        parseQueryStringLocalVar["level"] = ClientUtils.ParameterToString(level.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (putSubmodelElementByPathSubmodelRepoRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(putSubmodelElementByPathSubmodelRepoRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PutSubmodelElementByPathSubmodelRepoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PutSubmodelElementByPathSubmodelRepoApiResponse>();

                        PutSubmodelElementByPathSubmodelRepoApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPutSubmodelElementByPathSubmodelRepoDefaultImplementation(apiResponseLocalVar, submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level);

                        Events.ExecuteOnPutSubmodelElementByPathSubmodelRepo(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPutSubmodelElementByPathSubmodelRepoDefaultImplementation(e, "/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}", uriBuilderLocalVar.Path, submodelIdentifier, idShortPath, putSubmodelElementByPathSubmodelRepoRequest, level);
                Events.ExecuteOnErrorPutSubmodelElementByPathSubmodelRepo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PutSubmodelElementByPathSubmodelRepoApiResponse"/>
        /// </summary>
        public partial class PutSubmodelElementByPathSubmodelRepoApiResponse : MnestixSearcher.Clients.Client.ApiResponse, IPutSubmodelElementByPathSubmodelRepoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PutSubmodelElementByPathSubmodelRepoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PutSubmodelElementByPathSubmodelRepoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PutSubmodelElementByPathSubmodelRepoApiResponse(ILogger<PutSubmodelElementByPathSubmodelRepoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public MnestixSearcher.Clients.Model.Result? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<MnestixSearcher.Clients.Model.Result>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out MnestixSearcher.Clients.Model.Result? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
